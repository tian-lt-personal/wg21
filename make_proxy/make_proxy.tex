
\documentclass[10pt, a4paper, oneside]{article}
\usepackage{lipsum} %TODO: to be removed
\usepackage[margin=0.8in]{geometry}
\usepackage{hyperref}
\usepackage{amsmath}

\input{styles.tex}

\newcommand{\Cpp}{C\texttt{++}}
\makeatletter
\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
\begin{flushleft}
  \textbf{\huge \@title}

  \@author
\end{flushleft}\egroup
}
\makeatother

\title{Add make\_proxy for the Pointer-Semantics-Based
Polymorphism Library - Proxy}
\date{Sept. 15, 2024}
\author{%
\medbreak
Project: ISO/IEC 14882 Programming Languages â€” \Cpp{}, ISO/IEC JTC1/SC22/WG21\smallbreak
Authors: Tian Liao, Mingxin Wang\smallbreak
Reply-to: Tian Liao \textless tilia@microsoft.com\textgreater \smallbreak
Audience: LEWG
}

\begin{document}
\maketitle

\textbf{Abstract:} \textit{Proxy} is a new library feature that is being proposed to delegate general pointer types
with the type-erased technique to support non-intrusive polymorphism programming in \Cpp.
The focus of paper is on utility functions -- \textit{make\_proxy} and \textit{allocate\_proxy},
which used to be included in the \href{https://wg21.link/p3086r1}{\textit{proxy}} proposal as a sub-feature.
We believe they are useful tools to help allocate \textit{proxy} instances properly.

\section{Introduction}

Paper \href{https://wg21.link/p3086}{3086} proposed a \textit{Pointer-Semantics-Based Polymorphism Library},
which is designed to help people build extendable and efficient polymorphic programs with better abstractions and less intrusive code.
This paper is proposing the utility part that is separated from early versions of paper 3086 and \href{https://wg21.link/p0957}{0957}.

More specifically, we are eager to add function templates \textit{make\_proxy} and \textit{allocate\_proxy} together with the \textit{proxy} library into the standard as library features.
\textit{make\_proxy}'s syntax is similar to the constuctors of \verb|std::any|.
It is designed to provide simple ways to construct \textit{proxy} instances from values.
With \textit{make\_proxy}, SBO (small buffer optimization) may implicitly apply,
depending on library implementation,
to reduce the potential overheads that may come from invoking \textit{proxy}'s constructors directly.
\textit{allocate\_proxy}'s syntax is similar to \verb|std::allocate_shared|.
It is designed to help construct \textit{proxy} objects without the limitations of the size and the alignment for its underlying pointer type.

\section{Motivation}
Class template \textit{proxy} is based on pointer semantics,
which means instantiating a \textit{proxy} object from value usually involves heap allocations,
though sometimes those allocations could be evitable if the size of value's type is small enough.

For example, given the default maximum pointer size defined by \verb|F::constraints.max_size| is\smallbreak
\begin{equation*}
2 \times \texttt{sizeof(void*)}.
\end{equation*}
When users want to have a \textit{proxy} instance for an integer value $2024$, they may do
\begin{codeblock}
struct Any : some_facade_builder::build {};
std::proxy<Any> CreateYear() {
  return std::make_unique<int>(2024);  // implicitly converts to \verb|std::proxy<Any>|
}
\end{codeblock}
Apparently, \verb|std::make_unique<int>(2024)| performs an allocation,
which may be considered an expensive cost in certain scenarios.
To improve the construction from integer values in this case,
we shall introduce SBO here.
Because the storage size (e.g. 16 bytes on 64-bit machines) of \verb|std::proxy<Any>| is mostly sufficient to place a value of integer type (e.g. 4 bytes).
With the SBO capability provided by \textit{make\_proxy}, users can choose below implementation for the \verb|CreateYear()| function:
\begin{codeblock}
std::proxy<Any> CreateYear() {
  return std::make_proxy<Any>(2024);  // no heap allocation happens
}
\end{codeblock}
In simple words,
\textit{make\_proxy} shall first try constructing a \textit{proxy} object with given values stored inplace,
and then fall back to storing the given values in an arbitrary memory range with heap allocations if the first trial failed at compile-time.

\section{Technical specification}
\subsection{Additional synopsis for header \textless memory\textgreater}

\begin{codeblock}
namespace std {
  template <facade F, class T, class Alloc, class... Args>
  proxy<F> allocate_proxy(const Alloc& alloc, Args&&... args);

  template <facade F, class T, class Alloc, class U, class... Args>
  proxy<F> allocate_proxy(const Alloc& alloc, std::initializer_list<U> il, Args&&... args);

  template <facade F, class Alloc, class T>
  proxy<F> allocate_proxy(const Alloc& alloc, T&& value);

  template <facade F, class T, class... Args>
  proxy<F> make_proxy(Args&&... args);
  
  template <facade F, class T, class U, class... Args>
  proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);
  
  template <facade F, class T>
  proxy<F> make_proxy(T&& value);
}
\end{codeblock}

\noindent The above synopsis is assumming the \textit{memory} header has below synopsis defined in paper \href{https://wg21.link/p3086}{3086}:
\begin{codeblock}
namespace std {
  template <class F>
    concept facade // = see p3086;
  template <class F>
    class proxy; // see p3086
}

\end{codeblock}

\subsection{Function template \texttt{std::allocate\_proxy}}
The definition of \textit{allocate\_proxy} makes use of an exposition-only class template \textit{allocated-ptr}.
An object of type \verb|allocated-ptr<T, Alloc>| allocates the storage for another object of type T with an allocator of type Alloc and manages the lifetime of this contained object.
Similar with \verb|std::optional|, \verb|allocated-ptr<T, Alloc>| provides \verb|operator*| for accessing the contained object with the same qualifiers,
but does not necessarily support the state where the contained object is absent.\smallbreak
\textit{allocate\_proxy} returns a construct \textit{proxy} object. It may throw any exception thrown by allocation or the constructor of T.
\medbreak

\noindent 1. \verb|template <facade F, class T, class Alloc, class... Args>|\smallbreak
\verb|proxy<F> allocate_proxy(const Alloc& alloc, Args&&... args);|

\textit{Effects}: Creates a \verb|proxy<F>| object containing an \verb|allocated-ptr<T, Alloc>| direct-non-list-initialized with \verb|std::forward<Args>(args)...|.
\bigbreak

\noindent 2. \verb|template <facade F, class T, class Alloc, class U, class... Args>|\smallbreak
\verb|proxy<F> allocate_proxy(const Alloc& alloc, std::initializer_list<U> il, Args&&... args);|
\medbreak
\textit{Effects}: Creates a \verb|proxy<F>| object containing an \verb|allocated-ptr<T, Alloc>| direct-non-list-initialized with il, \verb|std::forward<Args>(args)...|.
\bigbreak

\noindent 3. \verb|template <facade F, class Alloc, class T>|\smallbreak
\indent \verb|proxy<F> allocate_proxy(const Alloc& alloc, T&& value);|
\medbreak
\textit{Effects}: Creates a \verb|proxy<F>| object containing an \verb|allocated-ptr<std::decay_t<T>, Alloc>| direct-non-list-initialized with \verb|std::forward<T>(value)|.

\subsection{Function template \texttt{std::make\_proxy}}
1. \verb|template <facade F, class T, class... Args>|\smallbreak
\indent \verb|proxy<F> make_proxy(Args&&... args);|

\textit{Effects}: Creates an instance of \verb|proxy<F>| with an unspecified pointer type of \verb|T|,
where the value of \verb|T| is direct-non-list-initialized with the arguments \verb|std::forward<Args>(args)....|

Remarks: Implementations are not permitted to use additional storage, such as dynamic memory, to
allocate the value of \verb|T| if the following conditions apply:
\begin{itemize}
  \item[--] \verb|sizeof(T)| $\le$ \verb|F::constraints.max_size|, and
  \item[--] \verb|alignof(T)| $\le$ \verb|F::constraints.max_align|, and
  \item[--] \verb|T| meets the copyiability requirements defined by \verb|F::constraints.copyability|, and
  \item[--] \verb|T| meets the relocatability requirements defined by \verb|F::constraints.relocatability|, and
  \item[--] \verb|T| meets the destructibility requirements defined by \verb|F::constraints.destructibility|.
\end{itemize}

\noindent 2. \verb|template <facade F, class T, class U, class... Args>|\smallbreak
\indent \verb|proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);|

\textit{Effects}: Equivalent to
\begin{codeblock}
  return make_proxy<F, T>(il, std::forward<Args>(args)...);
\end{codeblock}

\noindent 3. \verb|template <facade F, class T>|\smallbreak
\indent \verb|proxy<F> make_proxy(T&& value);|

\textit{Effects}: Equivalent to
\begin{codeblock}
  return make_proxy<F, decay_t<T>>(std::forward<T>(value));
\end{codeblock}

\section{Acknowledgements}
Thanks to Mingxin for his advanced work on \href{https://wg21.link/p0957}{P0957} and \href{https://wg21.link/p3086}{P3086}
and for giving me a chance to join him together to complete the work of \text{proxy}.

\section{References}
\begin{thebibliography}{9}
\bibitem{P3086}
[P3086] Proxy: A Pointer-Semantics-Based Polymorphism Library\smallbreak
Mingxin Wang

\bibitem{P0957}  
[P0957] Proxy: A Polymorphic Programming Library\smallbreak
Mingxin Wang

\bibitem{microsoft/proxy}
Open-source: Microsoft Proxy at GitHub\smallbreak
URL: https://github.com/microsoft/proxy
\end{thebibliography}



\end{document}
