
\documentclass[10pt, a4paper, oneside]{article}
\usepackage{lipsum} %TODO: to be removed
\usepackage[margin=0.8in]{geometry}
\usepackage{hyperref}

\input{styles.tex}

\newcommand{\Cpp}{C\texttt{++}}
\makeatletter
\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
\begin{flushleft}
  \textbf{\huge \@title}

  \@author
\end{flushleft}\egroup
}
\makeatother

\title{Add make\_proxy for the Pointer-Semantics-Based
Polymorphism Library - Proxy}
\date{Sept. 15, 2024}
\author{%
\ \\
Project: ISO/IEC 14882 Programming Languages â€” \Cpp, ISO/IEC JTC1/SC22/WG21\\
Authors: Tian Liao, Mingxin Wang\\
Reply-to: Tian Liao \textless tilia@microsoft.com\textgreater \\
Audience: LEWG\\
}

\begin{document}
\maketitle

\textbf{Abstract:} \textit{Proxy} is a new library feature that is being proposed to delegate general pointer types
with the type-erased technique to support non-intrusive polymorphism programming in \Cpp.
The focus of paper is on a utility function -- \textit{make\_proxy}, which used to be included in the \textit{proxy} proposal as a sub-feature.
We believe it's a useful tool to help allocate \textit{proxy} instances properly.

\section{Introduction}

Paper \href{https://wg21.link/p3086}{3086} proposed a \textit{Pointer-Semantics-Based Polymorphism Library},
which is designed to help people build extendable and efficient polymorphic programs with better abstractions and less intrusive code.
This paper is proposing the utility part that is separated from early versions of paper 3086 and paper \href{https://wg21.link/p0957}{0957}.

More specifically, we are eager to add function template \textit{make\_proxy} together with the \textit{proxy} library into the standard as a library feature.
\textit{make\_proxy}'s syntax is similar to the constuctors of \verb|std::any|. It is designed to provide simple ways to construct \textit{proxy} instances from values.
With \textit{make\_proxy}, SBO (small buffer optimization) may implicitly apply, depending on library implementation, to reduce the potential overheads that may come from invoking \textit{proxy}'s constructors directly.

\section{Motivation}
\lipsum[1]

\section{Technical specification}
\subsection{Additional synopsis for header \textless proxy\textgreater}

\begin{codeblock}
namespace std {
  template <facade F, class T, class... Args>
  proxy<F> make_proxy(Args&&... args);
  
  template <facade F, class T, class U, class... Args>
  proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);
  
  template <facade F, class T>
  proxy<F> make_proxy(T&& value);
}
\end{codeblock}

\noindent The above synopsis is assumming the proxy header has such synopsis defined in paper \href{https://wg21.link/p3086}{3086}:
\begin{codeblock}
namespace std {
  template <class F>
    concept facade // = see p3086;
  template <class F>
    class proxy; // see p3086
}

\end{codeblock}

\subsection{Function template \texttt{std::make\_proxy}}
1. \verb|template <facade F, class T, class... Args>|\\
\indent \verb|proxy<F> make_proxy(Args&&... args);|

\textit{Effects}: Creates an instance of \verb|proxy<F>| with an unspecified pointer type of \verb|T|,
where the value of \verb|T| is direct-non-list-initialized with the arguments \verb|std::forward<Args>(args)....|

Remarks: Implementations are not permitted to use additional storage, such as dynamic memory, to
allocate the value of \verb|T| if the following conditions apply:
\begin{itemize}
  \item[--] \verb|sizeof(T)| $\le$ \verb|F::constraints.max_size|, and
  \item[--] \verb|alignof(T)| $\le$ \verb|F::constraints.max_align|, and
  \item[--] \verb|T| meets the copyiability requirements defined by \verb|F::constraints.copyability|, and
  \item[--] \verb|T| meets the relocatability requirements defined by \verb|F::constraints.relocatability|, and
  \item[--] \verb|T| meets the destructibility requirements defined by \verb|F::constraints.destructibility|.
\end{itemize}

\noindent 2. \verb|template <facade F, class T, class U, class... Args>|\\
\indent \verb|proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);|

\textit{Effects}: Equivalent to
\begin{codeblock}
return make_proxy<F, T>(il, std::forward<Args>(args)...);
\end{codeblock}

\noindent 3. \verb|template <facade F, class T>|\\
\indent \verb|proxy<F> make_proxy(T&& value);|

\textit{Effects}: Equivalent to
\begin{codeblock}
return make_proxy<F, decay_t<T>>(std::forward<T>(value));
\end{codeblock}


\end{document}
