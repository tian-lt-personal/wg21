
\documentclass[10pt, a4paper, oneside]{article}
\usepackage{lipsum} %TODO: to be removed
\usepackage[margin=0.8in]{geometry}
\usepackage{hyperref}
\usepackage{amsmath}

\input{styles.tex}

\newcommand{\Cpp}{C\texttt{++}}
\makeatletter
\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
\begin{flushleft}
  \textbf{\huge \@title}

  \@author
\end{flushleft}\egroup
}
\makeatother

\title{Add make\_proxy for the Pointer-Semantics-Based
Polymorphism Library - Proxy}
\date{Sept. 15, 2024}
\author{%
\ \\
Project: ISO/IEC 14882 Programming Languages â€” \Cpp, ISO/IEC JTC1/SC22/WG21\\
Authors: Tian Liao, Mingxin Wang\\
Reply-to: Tian Liao \textless tilia@microsoft.com\textgreater \\
Audience: LEWG\\
}

\begin{document}
\maketitle

\textbf{Abstract:} \textit{Proxy} is a new library feature that is being proposed to delegate general pointer types
with the type-erased technique to support non-intrusive polymorphism programming in \Cpp.
The focus of paper is on utility functions -- \textit{make\_proxy} and \textit{allocate\_proxy},
which used to be included in the \href{https://wg21.link/p3086r1}{\textit{proxy}} proposal as a sub-feature.
We believe it's a useful tool to help allocate \textit{proxy} instances properly.

\section{Introduction}

Paper \href{https://wg21.link/p3086}{3086} proposed a \textit{Pointer-Semantics-Based Polymorphism Library},
which is designed to help people build extendable and efficient polymorphic programs with better abstractions and less intrusive code.
This paper is proposing the utility part that is separated from early versions of paper 3086 and paper \href{https://wg21.link/p0957}{0957}.

More specifically, we are eager to add function template \textit{make\_proxy} together with the \textit{proxy} library into the standard as a library feature.
\textit{make\_proxy}'s syntax is similar to the constuctors of \verb|std::any|. It is designed to provide simple ways to construct \textit{proxy} instances from values.
With \textit{make\_proxy}, SBO (small buffer optimization) may implicitly apply, depending on library implementation, to reduce the potential overheads that may come from invoking \textit{proxy}'s constructors directly.

\section{Motivation}
Class template \textit{proxy} is based on pointer semantics,
which means instantiating a \textit{proxy} object from value usually involves heap allocations,
though sometimes those allocations could be evitable if the size of value's type is small enough.

For example, given the default maximum pointer size defined by \verb|F::constraints.max_size| is\\
\begin{equation*}
2 \times \texttt{sizeof(void*)}.
\end{equation*}
When users want to have a \textit{proxy} instance for an integer value $2024$, they may do
\begin{codeblock}
struct Any : some_facade_builder::build {};
std::proxy<Any> CreateYearObject() {
  return std::make_unique<int>(2024);  // implicitly converts to \verb|std::proxy<Any>|
}
\end{codeblock}
Apparently, \verb|std::make_unique<int>(2024)| performs an allocation,
which may be considered an expensive cost in certain scenarios.
To improve the construction from integer values in this case,
we shall introduce SBO here.
Because the storage size (e.g. 16 bytes on 64-bit machines) of \verb|std::proxy<Any>| is mostly sufficient to place a value of integer type (e.g. 4 bytes).
With the SBO capability provided by \textit{make\_proxy}, users can choose below implementation for the \verb|CreateYearObject()| function:
\begin{codeblock}
struct Any : some_facade_builder::build {};
std::proxy<Any> CreateYearObject() {
  return std::make_proxy<Any>(2024);  // no heap allocation happens
}
\end{codeblock}
In simple words,
\textit{make\_proxy} shall first try constructing a \textit{proxy} object with given values stored inplace,
and then fall back to storing the given values in an arbitrary memory range with heap allocations if the first trial failed at compile-time.

\section{Technical specification}
\subsection{Additional synopsis for header \textless memory\textgreater}

\begin{codeblock}
namespace std {
  template <facade F, class T, class... Args>
  proxy<F> make_proxy(Args&&... args);
  
  template <facade F, class T, class U, class... Args>
  proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);
  
  template <facade F, class T>
  proxy<F> make_proxy(T&& value);
}
\end{codeblock}

\noindent The above synopsis is assumming the \textit{memory} header has below synopsis defined in paper \href{https://wg21.link/p3086}{3086}:
\begin{codeblock}
namespace std {
  template <class F>
    concept facade // = see p3086;
  template <class F>
    class proxy; // see p3086
}

\end{codeblock}

\subsection{Function template \texttt{std::make\_proxy}}
1. \verb|template <facade F, class T, class... Args>|\\
\indent \verb|proxy<F> make_proxy(Args&&... args);|

\textit{Effects}: Creates an instance of \verb|proxy<F>| with an unspecified pointer type of \verb|T|,
where the value of \verb|T| is direct-non-list-initialized with the arguments \verb|std::forward<Args>(args)....|

Remarks: Implementations are not permitted to use additional storage, such as dynamic memory, to
allocate the value of \verb|T| if the following conditions apply:
\begin{itemize}
  \item[--] \verb|sizeof(T)| $\le$ \verb|F::constraints.max_size|, and
  \item[--] \verb|alignof(T)| $\le$ \verb|F::constraints.max_align|, and
  \item[--] \verb|T| meets the copyiability requirements defined by \verb|F::constraints.copyability|, and
  \item[--] \verb|T| meets the relocatability requirements defined by \verb|F::constraints.relocatability|, and
  \item[--] \verb|T| meets the destructibility requirements defined by \verb|F::constraints.destructibility|.
\end{itemize}

\noindent 2. \verb|template <facade F, class T, class U, class... Args>|\\
\indent \verb|proxy<F> make_proxy(std::initializer_list<U> il, Args&&... args);|

\textit{Effects}: Equivalent to
\begin{codeblock}
  return make_proxy<F, T>(il, std::forward<Args>(args)...);
\end{codeblock}

\noindent 3. \verb|template <facade F, class T>|\\
\indent \verb|proxy<F> make_proxy(T&& value);|

\textit{Effects}: Equivalent to
\begin{codeblock}
  return make_proxy<F, decay_t<T>>(std::forward<T>(value));
\end{codeblock}

\section{Possible implementation}

\section{References}


\end{document}
